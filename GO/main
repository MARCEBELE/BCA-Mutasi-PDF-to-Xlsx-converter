package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Empty strings â€” no ANSI codes; GUI reads stdout as plain text.
const (
	ColorReset  = ""
	ColorGreen  = ""
	ColorYellow = ""
	ColorBlue   = ""
	ColorCyan   = ""
	ColorRed    = ""
)

func main() {
	var inputFiles []string
	for _, arg := range os.Args[1:] {
		ext := strings.ToLower(filepath.Ext(arg))
		if ext == ".txt" || ext == ".pdf" {
			inputFiles = append(inputFiles, arg)
		}
	}

	if len(inputFiles) == 0 {
		fmt.Println("BCA Statement Converter")
		fmt.Println("Usage: bca-converter.exe file1.pdf file2.txt ...")
		fmt.Println("       or use BCA_Converter.exe for the graphical interface")
		os.Exit(1)
	}

	success := 0
	failed := 0

	for _, inputFile := range inputFiles {
		ext := strings.ToLower(filepath.Ext(inputFile))

		txtFile := inputFile
		isTempTxt := false
		if ext == ".pdf" {
			fmt.Printf("Converting PDF: %s\n", filepath.Base(inputFile))
			converted, err := pdfToTxt(inputFile)
			if err != nil {
				fmt.Printf("ERROR: PDF conversion failed: %v\n", err)
				failed++
				continue
			}
			txtFile = converted
			isTempTxt = true
			fmt.Println("Converted to TXT OK")
		}

		base := strings.TrimSuffix(inputFile, filepath.Ext(inputFile))
		output := base + ".xlsx"

		fmt.Printf("Parsing: %s\n", filepath.Base(txtFile))

		parser := NewBCAParser(txtFile)
		err := parser.Parse()
		if err != nil {
			fmt.Printf("ERROR: %v\n", err)
			cleanupTemp(isTempTxt, txtFile)
			failed++
			continue
		}

		parser.PrintSummary()

		fmt.Println("Generating Excel...")
		err = parser.ExportToExcel(output)
		if err != nil {
			fmt.Printf("ERROR: %v\n", err)
			cleanupTemp(isTempTxt, txtFile)
			failed++
			continue
		}

		cleanupTemp(isTempTxt, txtFile)
		fmt.Printf("OK: %s\n\n", filepath.Base(output))
		success++
	}

	fmt.Println(strings.Repeat("=", 50))
	if failed == 0 {
		fmt.Printf("DONE: %d converted successfully\n", success)
	} else {
		fmt.Printf("DONE: %d OK, %d failed\n", success, failed)
	}
}

func cleanupTemp(isTemp bool, path string) {
	if isTemp {
		os.Remove(path)
	}
}

func pdfToTxt(pdfPath string) (string, error) {
	exePath, err := os.Executable()
	if err != nil {
		return "", fmt.Errorf("cannot find exe path: %w", err)
	}
	scriptPath := filepath.Join(filepath.Dir(exePath), "pdf_to_txt.py")

	if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
		return "", fmt.Errorf("pdf_to_txt.py not found - keep it in the same folder as the exe")
	}

	txtPath := strings.TrimSuffix(pdfPath, filepath.Ext(pdfPath)) + "_temp.txt"

	// Check Python is actually findable before trying to run
	var pyPath string
	for _, pyCmd := range []string{"python", "py", "python3"} {
		if p, err := exec.LookPath(pyCmd); err == nil {
			pyPath = p
			break
		}
	}
	if pyPath == "" {
		return "", fmt.Errorf("Python not found - install from https://python.org then: pip install pdfplumber")
	}

	cmd := exec.Command(pyPath, scriptPath, pdfPath, txtPath)
	// Strip PyInstaller env vars so the system Python uses its own home/stdlib,
	// not the bundled Python 3.x runtime that BCA_Converter.exe was built with.
	// PYTHONHOME in particular causes "Module use of pythonXXX.dll conflicts" errors.
	blocked := map[string]bool{
		"PYTHONHOME":        true,
		"PYTHONPATH":        true,
		"PYTHONSTARTUP":     true,
		"PYTHONOPTIMIZE":    true,
		"PYTHONDONTWRITEBYTECODE": true,
	}
	clean := os.Environ()[:0]
	for _, e := range os.Environ() {
		key := e
		if i := strings.Index(e, "="); i >= 0 {
			key = e[:i]
		}
		if !blocked[key] {
			clean = append(clean, e)
		}
	}
	cmd.Env = clean
	out, _ := cmd.CombinedOutput()
	if _, err := os.Stat(txtPath); err == nil {
		return txtPath, nil
	}

	if len(out) > 0 {
		return "", fmt.Errorf("Python script error:\n%s", strings.TrimSpace(string(out)))
	}
	return "", fmt.Errorf("Python ran but produced no output - check pdfplumber: pip install pdfplumber")
}
